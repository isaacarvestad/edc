#include <cmath>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <glog/stl_logging.h>
#include <iostream>
#include <numeric>
#include <vector>

#include "lib/cut_matching.hpp"
#include "lib/datastructures/undirected_graph.hpp"
#include "lib/expander_decomp.hpp"
#include "util.hpp"

using namespace std;

DEFINE_double(
    phi, 0.01,
    "Value of \\phi such that expansion of each cluster is at least \\phi");
DEFINE_int32(t1, 100, "Constant 't1' in 'T = t1 + t2 \\log^2 m'");
DEFINE_double(t2, 1.0, "Constant 't2' in 'T = t1 + t2 \\log^2 m'");
DEFINE_bool(chaco, false,
            "Input graph is given in the Chaco graph file format");
DEFINE_int32(verify_expansion, 0,
             "Number of times an expansion certificate generated by the "
             "cut-matching game should be sampled");

int main(int argc, char *argv[]) {
  google::InitGoogleLogging(argv[0]);

  gflags::SetUsageMessage("Expander Decomposition & Clustering");
  gflags::ParseCommandLineFlags(&argc, &argv, true);

  VLOG(1) << "Reading input.";
  auto g = readGraph(FLAGS_chaco);
  VLOG(1) << "Finished reading input.";

  auto graph = ExpanderDecomposition::constructFlowGraph(g);
  auto subdivGraph = ExpanderDecomposition::constructSubdivisionFlowGraph(g);

  CutMatching::Solver solver(graph.get(), subdivGraph.get(), FLAGS_phi,
                             FLAGS_t1, FLAGS_t2, FLAGS_verify_expansion);
  auto result = solver.compute();
  std::vector<int> a, r;
  std::copy(graph->cbegin(), graph->cend(), std::back_inserter(a));
  std::copy(graph->cbeginRemoved(), graph->cendRemoved(),
            std::back_inserter(r));

  switch (result.type) {
  case CutMatching::Balanced: {
    cout << "balanced_cut";
    break;
  }
  case CutMatching::NearExpander: {
    cout << "near_expander";
    break;
  }
  case CutMatching::Expander: {
    cout << "expander";
    break;
  }
  }
  cout << " " << result.iterations << endl;

  cout << a.size();
  for (auto u : a)
    cout << " " << u;
  cout << endl;
  cout << r.size();
  for (auto u : r)
    cout << " " << u;
  cout << endl;

  if (FLAGS_verify_expansion > 0) {
    cout << result.certificateSamples.size() << " " << FLAGS_verify_expansion
         << endl;
    for (const auto &samples : result.certificateSamples) {
      assert(samples.size() == FLAGS_verify_expansion &&
             "Incorrect number of expansion certificate samples.");
      bool first = true;
      for (auto sample : samples) {
        if (!first)
          cout << " ";
        else
          first = false;
        cout << sample;
      }
      cout << endl;
    }
  }
}
